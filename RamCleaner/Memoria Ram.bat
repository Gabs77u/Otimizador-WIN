@ECHO OFF
setlocal EnableDelayedExpansion

:: ============================================================================
::   üöÄ OTIMIZADOR DE MEM√ìRIA RAM v3.0 - By Gabs
::   Libera√ß√£o inteligente de mem√≥ria com interface moderna
:: ============================================================================
::
::   Copyright (c) 2025 Gabs77u
::   Licensed under Creative Commons Attribution-NonCommercial 4.0 International
::   License (CC BY-NC 4.0)
::   
::   You are free to use, share, and adapt this work for non-commercial purposes
::   with proper attribution. Commercial use is prohibited.
::   
::   For full license terms, see: LICENSE file or
::   https://creativecommons.org/licenses/by-nc/4.0/
::
:: ============================================================================

:: Configura√ß√µes globais
set "INTERVALO=30"
set "MONITOR_REFRESH=2"
set "MONITOR_ALERT_LEVEL=85"
set "VERSION=3.0"
set "AUTHOR=Gabs"
set "ERRO_LEVEL=0"

:: ============================================================================
::   üöÄ OTIMIZADOR DE MEM√ìRIA RAM v3.0 - By Gabs
::   Libera√ß√£o inteligente de mem√≥ria com interface moderna
:: ============================================================================

title OTIMIZADOR DE MEMORIA RAM v3.0 - By Gabs
chcp 65001 > NUL 2>&1
mode 80,25

echo üìä ESTAT√çSTICAS:
echo    ‚Ä¢ Mostra uso detalhado de mem√≥ria
echo    ‚Ä¢ Lista processos com maior consumo
echo    ‚Ä¢ Informa√ß√µes de mem√≥ria virtual
echo.
echo üìà MONITOR EM TEMPO REAL:
echo    ‚Ä¢ Monitor visual de mem√≥ria em tempo real
echo    ‚Ä¢ Barra de progresso ASCII colorida
echo    ‚Ä¢ Alertas configur√°veis por n√≠vel de uso
echo    ‚Ä¢ Lista dos processos com maior consumo
echo    ‚Ä¢ Atualiza√ß√£o autom√°tica configur√°vel

:: Verifica√ß√£o de privil√©gios administrativos
call :CheckAdmin
if !ERRO_LEVEL! neq 0 (
    echo.
    echo ‚ö†Ô∏è  AVISO: Executando sem privil√©gios administrativos
    echo.
    echo üí° FUNCIONALIDADES DISPON√çVEIS:
    echo    ‚Ä¢ Visualiza√ß√£o de estat√≠sticas de mem√≥ria
    echo    ‚Ä¢ Monitor em tempo real
    echo    ‚Ä¢ Limpeza b√°sica de mem√≥ria .NET
    echo.
    echo ÔøΩ FUNCIONALIDADES LIMITADAS:
    echo    ‚Ä¢ Limpeza avan√ßada de arquivos (requer admin)
    echo    ‚Ä¢ Acesso completo ao sistema (requer admin)
    echo.
    echo üîß Para funcionalidade completa: Execute como administrador
    echo.
    set "ADMIN_MODE=0"
    pause
) else (
    set "ADMIN_MODE=1"
)

:: Obter informa√ß√µes de mem√≥ria inicial
call :GetMemoryInfo inicial

:MainMenu
cls
call :DrawHeader
call :ShowMemoryStatus
call :DrawMenu
echo.
set /p "OPCAO=üéØ Digite sua op√ß√£o: "

if "!OPCAO!"=="1" goto :CleanupMemory
if "!OPCAO!"=="2" goto :AutoCleanup
if "!OPCAO!"=="3" goto :AdvancedCleanup
if "!OPCAO!"=="4" goto :ShowStats
if "!OPCAO!"=="5" goto :RealTimeMonitor
if "!OPCAO!"=="6" goto :Settings
if "!OPCAO!"=="0" goto :Exit
if "!OPCAO!"=="?" goto :Help

cls
echo.
echo ‚ùå Op√ß√£o inv√°lida! Tente novamente.
timeout /t 2 > NUL
goto :MainMenu

:: ============================================================================
::   üé® INTERFACE E VISUAL
:: ============================================================================

:DrawHeader
echo.
echo ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
echo ‚ïë                    üöÄ OTIMIZADOR DE MEM√ìRIA RAM v%VERSION%                    ‚ïë
echo ‚ïë                              By %AUTHOR% - 2025                              ‚ïë
echo ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
echo.
goto :eof

:DrawMenu
echo ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
echo ‚ïë                            üìã MENU PRINCIPAL                             ‚ïë
echo ‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
if "!ADMIN_MODE!"=="1" (
    echo ‚ïë  [1] üßπ Limpeza R√°pida de Mem√≥ria                                        ‚ïë
    echo ‚ïë  [2] ‚ö° Limpeza Autom√°tica (A cada %INTERVALO%s^)                               ‚ïë
    echo ‚ïë  [3] üîß Limpeza Avan√ßada + Arquivos                                      ‚ïë
) else (
    echo ‚ïë  [1] üßπ Limpeza B√°sica de Mem√≥ria (Sem Admin^)                           ‚ïë
    echo ‚ïë  [2] ‚ö° Limpeza Autom√°tica B√°sica                                        ‚ïë
    echo ‚ïë  [3] üîí Limpeza Avan√ßada (Requer Admin^)                                 ‚ïë
)
echo ‚ïë  [4] üìä Estat√≠sticas de Mem√≥ria                                          ‚ïë
echo ‚ïë  [5] üìà Monitor em Tempo Real                                            ‚ïë
echo ‚ïë  [6] ‚öôÔ∏è  Configura√ß√µes                                                    ‚ïë
echo ‚ïë  [?] ‚ùì Ajuda                                                             ‚ïë
echo ‚ïë  [0] üö™ Sair                                                              ‚ïë
echo ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
goto :eof

:ShowMemoryStatus
:: Usar PowerShell como m√©todo prim√°rio para obter informa√ß√µes de mem√≥ria
for /f "tokens=*" %%a in ('powershell -Command "(Get-CimInstance -ClassName Win32_OperatingSystem).TotalVisibleMemorySize" 2^>nul') do set "TOTAL_KB=%%a"
for /f "tokens=*" %%a in ('powershell -Command "(Get-CimInstance -ClassName Win32_OperatingSystem).FreePhysicalMemory" 2^>nul') do set "FREE_KB=%%a"

:: Se PowerShell falhar, tentar WMIC como fallback
if not defined TOTAL_KB (
    for /f "skip=1 tokens=*" %%a in ('wmic OS get TotalVisibleMemorySize /value 2^>nul ^| findstr "="') do (
        for /f "tokens=2 delims==" %%b in ("%%a") do set "TOTAL_KB=%%b"
    )
)
if not defined FREE_KB (
    for /f "skip=1 tokens=*" %%a in ('wmic OS get FreePhysicalMemory /value 2^>nul ^| findstr "="') do (
        for /f "tokens=2 delims==" %%b in ("%%a") do set "FREE_KB=%%b"
    )
)

if defined TOTAL_KB if defined FREE_KB (
    set /a "TOTAL_MB=!TOTAL_KB!/1024"
    set /a "FREE_MB=!FREE_KB!/1024"
    set /a "USED_MB=!TOTAL_MB!-!FREE_MB!"
    set /a "PERCENT_USED=(!USED_MB!*100)/!TOTAL_MB!"
    
    echo üíª MEM√ìRIA RAM: !USED_MB!MB/!TOTAL_MB!MB usados (!PERCENT_USED!%% ocupado^) - Livre: !FREE_MB!MB
) else (
    echo üíª MEM√ìRIA RAM: Informa√ß√µes n√£o dispon√≠veis
)
echo.
goto :eof

:: ============================================================================
::   üîê VERIFICA√á√ÉO DE PRIVIL√âGIOS
:: ============================================================================

:CheckAdmin
set "ERRO_LEVEL=0"
net session >nul 2>&1
if %errorlevel% neq 0 (
    set "ERRO_LEVEL=1"
)
goto :eof

:: ============================================================================
::   üßπ FUN√á√ïES DE LIMPEZA DE MEM√ìRIA
:: ============================================================================

:CleanupMemory
cls
call :DrawHeader
if "!ADMIN_MODE!"=="1" (
    echo üßπ INICIANDO LIMPEZA R√ÅPIDA DE MEM√ìRIA...
) else (
    echo üßπ INICIANDO LIMPEZA B√ÅSICA DE MEM√ìRIA (SEM ADMIN)...
    echo.
    echo ‚ö†Ô∏è  Modo limitado: Algumas opera√ß√µes podem n√£o funcionar
)
echo.

call :ConfirmAction "Executar limpeza de mem√≥ria"
if !ERRO_LEVEL! neq 0 goto :MainMenu

echo ‚úÖ Iniciando processo de limpeza...
echo.

call :GetMemoryInfo before

echo üîÑ [1/5] For√ßando coleta de lixo do .NET Framework...
powershell -Command "[System.GC]::Collect(); [System.GC]::WaitForPendingFinalizers(); [System.GC]::Collect()" 2>nul

if "!ADMIN_MODE!"=="1" (
    echo üîÑ [2/5] Limpando cache do sistema...
    %windir%\system32\rundll32.exe advapi32.dll,ProcessIdleTasks
    
    echo üîÑ [3/5] Liberando mem√≥ria de aplica√ß√µes inativas...
    powershell -Command "Get-Process | Where-Object {$_.WorkingSet -gt 100MB -and $_.ProcessName -notlike '*svchost*'} | ForEach-Object {$_.CloseMainWindow()}" 2>nul
    
    echo üîÑ [4/5] Compactando mem√≥ria virtual...
    powershell -Command "[System.Runtime.GCSettings]::LargeObjectHeapCompactionMode = 'CompactOnce'; [System.GC]::Collect()" 2>nul
    
    echo üîÑ [5/5] Otimizando cache de p√°ginas...
    rundll32.exe kernel32.dll,SetProcessWorkingSetSize -1,-1 2>nul
) else (
    echo üîÑ [2/5] Compactando mem√≥ria virtual...
    powershell -Command "[System.Runtime.GCSettings]::LargeObjectHeapCompactionMode = 'CompactOnce'; [System.GC]::Collect()" 2>nul
    
    echo ‚ö†Ô∏è  [3/5] Cache do sistema (requer admin) - PULADO
    echo ‚ö†Ô∏è  [4/5] Aplica√ß√µes inativas (requer admin) - PULADO  
    echo ‚ö†Ô∏è  [5/5] Cache de p√°ginas (requer admin) - PULADO
)

call :GetMemoryInfo after
call :ShowCleanupResults

echo.
if "!ADMIN_MODE!"=="1" (
    echo ‚úÖ Limpeza r√°pida conclu√≠da com sucesso!
) else (
    echo ‚úÖ Limpeza b√°sica conclu√≠da! Execute como admin para limpeza completa.
)
echo.
pause
goto :MainMenu

:AutoCleanup
cls
call :DrawHeader
echo ‚ö° MODO LIMPEZA AUTOM√ÅTICA ATIVADO
echo.
echo ‚ö†Ô∏è  Esta op√ß√£o executar√° limpeza autom√°tica a cada %INTERVALO% segundos
echo    Para parar, pressione Ctrl+C ou feche esta janela
echo.

call :ConfirmAction "Ativar limpeza autom√°tica"
if !ERRO_LEVEL! neq 0 goto :MainMenu

:AutoLoop
cls
echo ‚ö° LIMPEZA AUTOM√ÅTICA ATIVA - Intervalo: %INTERVALO%s
echo ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
echo.
echo üïê Pr√≥xima limpeza em: %INTERVALO% segundos
echo üí° Pressione Ctrl+C para parar
echo.

call :QuickMemoryClean

echo.
echo ‚è∞ Aguardando pr√≥ximo ciclo...
timeout /t %INTERVALO% > NUL
goto :AutoLoop

:AdvancedCleanup
cls
call :DrawHeader
echo üîß LIMPEZA AVAN√áADA DE MEM√ìRIA + ARQUIVOS
echo.
if "!ADMIN_MODE!"=="0" (
    echo ‚ùå ERRO: Esta funcionalidade requer privil√©gios administrativos!
    echo.
    echo üîß SOLU√á√ÉO: Execute o programa como administrador
    echo üí° ALTERNATIVA: Use a op√ß√£o [1] para limpeza b√°sica
    echo.
    pause
    goto :MainMenu
)

echo ‚ö†Ô∏è  Esta op√ß√£o incluir√°:
echo    ‚Ä¢ Limpeza completa de mem√≥ria RAM
echo    ‚Ä¢ Remo√ß√£o de arquivos tempor√°rios
echo    ‚Ä¢ Limpeza de cache do sistema
echo    ‚Ä¢ Otimiza√ß√£o de prefetch
echo.

call :ConfirmAction "Executar limpeza avan√ßada"
if !ERRO_LEVEL! neq 0 goto :MainMenu

call :GetMemoryInfo before

echo ‚úÖ Iniciando limpeza avan√ßada...
echo.

:: Limpeza de mem√≥ria
echo üß† [1/8] Limpeza de mem√≥ria RAM...
call :QuickMemoryClean

:: Limpeza de arquivos tempor√°rios
echo üìÅ [2/8] Limpando arquivos tempor√°rios do sistema...
call :CleanTempFiles "c:\windows\temp" "Temp do Sistema"

echo üìÅ [3/8] Limpando arquivos tempor√°rios do usu√°rio...
call :CleanTempFiles "%temp%" "Temp do Usu√°rio"

echo üìÅ [4/8] Limpando cache de prefetch...
call :CleanTempFiles "c:\windows\prefetch" "Prefetch"

echo üìÅ [5/8] Limpando arquivos baixados...
call :CleanTempFiles "c:\windows\Downloaded Program Files" "Downloads do Sistema"

echo üßπ [6/8] Limpando lixeira...
powershell -Command "Clear-RecycleBin -Force" 2>nul

echo üîÑ [7/8] Desfragmentando mem√≥ria...
powershell -Command "[System.GC]::Collect(); [System.GC]::WaitForPendingFinalizers(); [System.GC]::Collect()" 2>nul

echo ‚ö° [8/8] Otimiza√ß√£o final...
%windir%\system32\rundll32.exe advapi32.dll,ProcessIdleTasks

call :GetMemoryInfo after
call :ShowCleanupResults

echo.
echo ‚úÖ Limpeza avan√ßada conclu√≠da com sucesso!
echo.
pause
goto :MainMenu

:: ============================================================================
::   üìä ESTAT√çSTICAS E INFORMA√á√ïES
:: ============================================================================

:ShowStats
cls
call :DrawHeader
echo üìä ESTAT√çSTICAS DETALHADAS DE MEM√ìRIA
echo ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
echo.

:: Informa√ß√µes de mem√≥ria f√≠sica
for /f "skip=1 tokens=*" %%a in ('wmic computersystem get TotalPhysicalMemory /value 2^>nul ^| findstr "="') do (
    for /f "tokens=2 delims==" %%b in ("%%a") do set "TOTAL_BYTES=%%b"
)
for /f "skip=1 tokens=*" %%a in ('wmic OS get TotalVisibleMemorySize /value 2^>nul ^| findstr "="') do (
    for /f "tokens=2 delims==" %%b in ("%%a") do set "TOTAL_KB=%%b"
)
for /f "skip=1 tokens=*" %%a in ('wmic OS get FreePhysicalMemory /value 2^>nul ^| findstr "="') do (
    for /f "tokens=2 delims==" %%b in ("%%a") do set "FREE_KB=%%b"
)

if defined TOTAL_KB if defined FREE_KB (
    set /a "TOTAL_MB=!TOTAL_KB!/1024"
    set /a "TOTAL_GB=!TOTAL_MB!/1024"
    set /a "FREE_MB=!FREE_KB!/1024"
    set /a "USED_MB=!TOTAL_MB!-!FREE_MB!"
    set /a "PERCENT_USED=(!USED_MB!*100)/!TOTAL_MB!"
    set /a "PERCENT_FREE=100-!PERCENT_USED!"
    
    echo üñ•Ô∏è  MEM√ìRIA F√çSICA TOTAL: !TOTAL_GB! GB (!TOTAL_MB! MB^)
    echo üíö MEM√ìRIA LIVRE: !FREE_MB! MB (!PERCENT_FREE!%^)
    echo üî¥ MEM√ìRIA USADA: !USED_MB! MB (!PERCENT_USED!%^)
)

echo.
echo üîç PROCESSOS COM MAIOR USO DE MEM√ìRIA:
echo ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
powershell -Command "Get-Process | Sort-Object WorkingSet -Descending | Select-Object -First 10 ProcessName, @{Name='Memory(MB)';Expression={[math]::Round($_.WorkingSet/1MB,2)}} | Format-Table -AutoSize" 2>nul

echo.
echo üíæ INFORMA√á√ïES DE MEM√ìRIA VIRTUAL:
for /f "skip=1 tokens=*" %%a in ('wmic OS get TotalVirtualMemorySize /value 2^>nul ^| findstr "="') do (
    for /f "tokens=2 delims==" %%b in ("%%a") do set "VIRTUAL_KB=%%b"
)
for /f "skip=1 tokens=*" %%a in ('wmic OS get FreeVirtualMemory /value 2^>nul ^| findstr "="') do (
    for /f "tokens=2 delims==" %%b in ("%%a") do set "FREE_VIRTUAL_KB=%%b"
)

if defined VIRTUAL_KB if defined FREE_VIRTUAL_KB (
    set /a "VIRTUAL_MB=!VIRTUAL_KB!/1024"
    set /a "FREE_VIRTUAL_MB=!FREE_VIRTUAL_KB!/1024"
    set /a "USED_VIRTUAL_MB=!VIRTUAL_MB!-!FREE_VIRTUAL_MB!"
    
    echo    Total Virtual: !VIRTUAL_MB! MB
    echo    Livre Virtual: !FREE_VIRTUAL_MB! MB
    echo    Usada Virtual: !USED_VIRTUAL_MB! MB
)

echo.
pause
goto :MainMenu

:: ============================================================================
::   üìà MONITOR EM TEMPO REAL
:: ============================================================================

:RealTimeMonitor
cls
call :DrawHeader
echo üìà MONITOR DE MEM√ìRIA EM TEMPO REAL
echo.
echo ‚ö†Ô∏è  INSTRU√á√ïES:
echo    ‚Ä¢ Atualiza√ß√£o autom√°tica a cada %MONITOR_REFRESH% segundos
echo    ‚Ä¢ Pressione Ctrl+C para parar e voltar ao menu
echo    ‚Ä¢ ESC tamb√©m funciona para sair
echo.
echo üöÄ Iniciando monitor...
timeout /t 3 > NUL

:MonitorLoop
cls
call :DrawHeader
echo üìà MONITOR DE MEM√ìRIA EM TEMPO REAL - Atualiza√ß√£o a cada %MONITOR_REFRESH%s
echo ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
echo ‚ïë                          üñ•Ô∏è  SISTEMA DE MONITORAMENTO                      ‚ïë
echo ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù

:: Obter dados de mem√≥ria
call :GetRealTimeMemoryData

:: Exibir informa√ß√µes b√°sicas
echo.
echo üíæ MEM√ìRIA F√çSICA:
echo ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
echo ‚îÇ Total: !TOTAL_MB! MB (!TOTAL_GB! GB^)                                          ‚îÇ
echo ‚îÇ Usada: !USED_MB! MB (!PERCENT_USED!%^)                                          ‚îÇ
echo ‚îÇ Livre: !FREE_MB! MB (!PERCENT_FREE!%^)                                          ‚îÇ
echo ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

:: Barra de progresso ASCII
call :DrawMemoryBar !PERCENT_USED!

:: CPU e outros dados
echo.
echo üî• RECURSOS DO SISTEMA:
echo ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
for /f "tokens=2 delims==" %%a in ('wmic cpu get loadpercentage /value ^| find "="') do set "CPU_USAGE=%%a"
if defined CPU_USAGE (
    echo ‚îÇ üñ•Ô∏è  CPU: !CPU_USAGE!%% de uso                                                 ‚îÇ
) else (
    echo ‚îÇ üñ•Ô∏è  CPU: Carregando...                                                      ‚îÇ
)

:: Processos top 5
echo ‚îÇ üîç TOP 5 PROCESSOS POR MEM√ìRIA:                                             ‚îÇ
powershell -Command "$procs = Get-Process | Sort-Object WorkingSet -Descending | Select-Object -First 5; foreach($p in $procs) { $mem = [math]::Round($p.WorkingSet/1MB,1); Write-Host ('‚îÇ   ' + $p.ProcessName.PadRight(25) + $mem.ToString().PadLeft(8) + ' MB'.PadRight(15) + '‚îÇ') }" 2>nul
echo ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

:: Status e alertas
echo.
call :ShowMemoryAlerts !PERCENT_USED!

:: Informa√ß√µes de atualiza√ß√£o
echo.
echo ‚è∞ √öltima atualiza√ß√£o: %TIME%
echo üí° Pressione Ctrl+C para parar o monitor
echo.

:: Aguardar 2 segundos e repetir
timeout /t 2 > NUL
goto :MonitorLoop

:: ============================================================================
::   üé® FUN√á√ïES DO MONITOR
:: ============================================================================

:GetRealTimeMemoryData
:: Usar PowerShell como m√©todo prim√°rio
for /f "tokens=*" %%a in ('powershell -Command "(Get-CimInstance -ClassName Win32_OperatingSystem).TotalVisibleMemorySize" 2^>nul') do set "TOTAL_KB=%%a"
for /f "tokens=*" %%a in ('powershell -Command "(Get-CimInstance -ClassName Win32_OperatingSystem).FreePhysicalMemory" 2^>nul') do set "FREE_KB=%%a"

:: Fallback para WMIC se PowerShell falhar
if not defined TOTAL_KB (
    for /f "skip=1 tokens=*" %%a in ('wmic OS get TotalVisibleMemorySize /value 2^>nul ^| findstr "="') do (
        for /f "tokens=2 delims==" %%b in ("%%a") do set "TOTAL_KB=%%b"
    )
)
if not defined FREE_KB (
    for /f "skip=1 tokens=*" %%a in ('wmic OS get FreePhysicalMemory /value 2^>nul ^| findstr "="') do (
        for /f "tokens=2 delims==" %%b in ("%%a") do set "FREE_KB=%%b"
    )
)

if defined TOTAL_KB if defined FREE_KB (
    set /a "TOTAL_MB=!TOTAL_KB!/1024"
    set /a "TOTAL_GB=!TOTAL_MB!/1024"
    set /a "FREE_MB=!FREE_KB!/1024"
    set /a "USED_MB=!TOTAL_MB!-!FREE_MB!"
    set /a "PERCENT_USED=(!USED_MB!*100)/!TOTAL_MB!"
    set /a "PERCENT_FREE=100-!PERCENT_USED!"
) else (
    set "TOTAL_MB=N/A"
    set "FREE_MB=N/A"
    set "USED_MB=N/A"
    set "PERCENT_USED=0"
    set "PERCENT_FREE=0"
)
goto :eof

:DrawMemoryBar
set "PERCENT=%~1"
set "BAR_LENGTH=50"
set /a "FILLED_CHARS=(!PERCENT!*!BAR_LENGTH!)/100"
set /a "EMPTY_CHARS=!BAR_LENGTH!-!FILLED_CHARS!"

:: Escolher cor baseada na porcentagem
if !PERCENT! geq 90 (
    set "BAR_COLOR=üî¥"
    set "BAR_CHAR=‚ñà"
) else if !PERCENT! geq 75 (
    set "BAR_COLOR=üü°"
    set "BAR_CHAR=‚ñà"
) else (
    set "BAR_COLOR=üü¢"
    set "BAR_CHAR=‚ñà"
)

echo.
echo %BAR_COLOR% BARRA DE USO DE MEM√ìRIA:
echo ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
set "PROGRESS_BAR=‚îÇ ["

:: Criar barra preenchida
for /l %%i in (1,1,!FILLED_CHARS!) do set "PROGRESS_BAR=!PROGRESS_BAR!!BAR_CHAR!"

:: Criar barra vazia
for /l %%i in (1,1,!EMPTY_CHARS!) do set "PROGRESS_BAR=!PROGRESS_BAR! "

set "PROGRESS_BAR=!PROGRESS_BAR!] !PERCENT!%%"

:: Preencher at√© o final da linha
for /l %%i in (1,1,20) do set "PROGRESS_BAR=!PROGRESS_BAR! "
set "PROGRESS_BAR=!PROGRESS_BAR!‚îÇ"

echo !PROGRESS_BAR!
echo ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
goto :eof

:ShowMemoryAlerts
set "USAGE=%~1"

echo üö® STATUS DO SISTEMA:
echo ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê

if !USAGE! geq 95 (
    echo ‚îÇ üî¥ CR√çTICO: Mem√≥ria quase esgotada! Execute limpeza imediatamente!         ‚îÇ
    echo ‚îÇ üí° Recomenda√ß√£o: Feche aplicativos desnecess√°rios                          ‚îÇ
) else if !USAGE! geq !MONITOR_ALERT_LEVEL! (
    echo ‚îÇ üü° ALTO: Uso elevado de mem√≥ria. Considere executar limpeza.               ‚îÇ
    echo ‚îÇ üí° Recomenda√ß√£o: Monitor processos e execute limpeza se necess√°rio         ‚îÇ
) else if !USAGE! geq 70 (
    echo ‚îÇ üü† MODERADO: Uso normal-alto de mem√≥ria.                                   ‚îÇ
    echo ‚îÇ üí° Recomenda√ß√£o: Monitoramento normal                                      ‚îÇ
) else (
    echo ‚îÇ üü¢ NORMAL: Uso de mem√≥ria em n√≠veis saud√°veis.                             ‚îÇ
    echo ‚îÇ üí° Status: Sistema operando normalmente                                    ‚îÇ
)

echo ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
goto :eof

:Settings
cls
call :DrawHeader
echo ‚öôÔ∏è  CONFIGURA√á√ïES DO OTIMIZADOR
echo ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
echo.
echo üìã CONFIGURA√á√ïES ATUAIS:
echo    ‚Ä¢ Intervalo de limpeza autom√°tica: %INTERVALO% segundos
echo    ‚Ä¢ Intervalo do monitor: %MONITOR_REFRESH% segundos
echo    ‚Ä¢ N√≠vel de alerta: %MONITOR_ALERT_LEVEL%%%
echo    ‚Ä¢ Vers√£o: %VERSION%
echo    ‚Ä¢ Modo de execu√ß√£o: Administrador
echo.
echo ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
echo ‚ïë  [1] üïê Alterar intervalo de limpeza autom√°tica                           ‚ïë
echo ‚ïë  [2] üîÑ Restaurar configura√ß√µes padr√£o                                   ‚ïë
echo ‚ïë  [3] ‚öôÔ∏è  Configurar monitor em tempo real                                ‚ïë
echo ‚ïë  [0] üîô Voltar ao menu principal                                         ‚ïë
echo ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
echo.
set /p "CONFIG=üéØ Digite sua op√ß√£o: "

if "!CONFIG!"=="1" goto :ChangeInterval
if "!CONFIG!"=="2" goto :RestoreDefaults
if "!CONFIG!"=="3" goto :MonitorSettings
if "!CONFIG!"=="0" goto :MainMenu

echo ‚ùå Op√ß√£o inv√°lida!
timeout /t 2 > NUL
goto :Settings

:ChangeInterval
echo.
echo üïê ALTERAR INTERVALO DE LIMPEZA AUTOM√ÅTICA
echo ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
echo.
echo Intervalo atual: %INTERVALO% segundos
echo Intervalo recomendado: 30-300 segundos
echo.
set /p "NOVO_INTERVALO=Digite o novo intervalo (em segundos): "

if "!NOVO_INTERVALO!" geq "10" if "!NOVO_INTERVALO!" leq "3600" (
    set "INTERVALO=!NOVO_INTERVALO!"
    echo.
    echo ‚úÖ Intervalo alterado para !INTERVALO! segundos!
) else (
    echo.
    echo ‚ùå Intervalo inv√°lido! Use valores entre 10 e 3600 segundos.
)
echo.
pause
goto :Settings

:MonitorSettings
echo.
echo ‚öôÔ∏è  CONFIGURA√á√ïES DO MONITOR EM TEMPO REAL
echo ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
echo.
echo üìä Configura√ß√µes atuais do monitor:
echo    ‚Ä¢ Intervalo de atualiza√ß√£o: %MONITOR_REFRESH% segundos
echo    ‚Ä¢ N√≠vel de alerta de mem√≥ria: %MONITOR_ALERT_LEVEL%%%
echo.
echo ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
echo ‚ïë  [1] üîÑ Alterar intervalo de atualiza√ß√£o                                 ‚ïë
echo ‚ïë  [2] üö® Alterar n√≠vel de alerta                                          ‚ïë
echo ‚ïë  [3] üß™ Testar monitor                                                   ‚ïë
echo ‚ïë  [0] üîô Voltar                                                           ‚ïë
echo ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
echo.
set /p "MONITOR_CONFIG=üéØ Digite sua op√ß√£o: "

if "!MONITOR_CONFIG!"=="1" goto :ChangeMonitorRefresh
if "!MONITOR_CONFIG!"=="2" goto :ChangeAlertLevel
if "!MONITOR_CONFIG!"=="3" goto :TestMonitor
if "!MONITOR_CONFIG!"=="0" goto :Settings

echo ‚ùå Op√ß√£o inv√°lida!
timeout /t 2 > NUL
goto :MonitorSettings

:ChangeMonitorRefresh
echo.
echo üîÑ ALTERAR INTERVALO DE ATUALIZA√á√ÉO DO MONITOR
echo ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
echo.
echo Intervalo atual: %MONITOR_REFRESH% segundos
echo Intervalo recomendado: 1-10 segundos
echo.
echo ‚ö†Ô∏è  Nota: Intervalos muito baixos (1s) podem consumir mais CPU
echo.
set /p "NOVO_REFRESH=Digite o novo intervalo (em segundos): "

if "!NOVO_REFRESH!" geq "1" if "!NOVO_REFRESH!" leq "60" (
    set "MONITOR_REFRESH=!NOVO_REFRESH!"
    echo.
    echo ‚úÖ Intervalo de atualiza√ß√£o alterado para !MONITOR_REFRESH! segundos!
) else (
    echo.
    echo ‚ùå Intervalo inv√°lido! Use valores entre 1 e 60 segundos.
)
echo.
pause
goto :MonitorSettings

:ChangeAlertLevel
echo.
echo üö® ALTERAR N√çVEL DE ALERTA DE MEM√ìRIA
echo ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
echo.
echo N√≠vel atual: %MONITOR_ALERT_LEVEL%%%
echo.
echo üí° N√≠veis recomendados:
echo    ‚Ä¢ 70%% - Alerta precoce
echo    ‚Ä¢ 80%% - Alerta moderado (recomendado)
echo    ‚Ä¢ 90%% - Alerta apenas em situa√ß√µes cr√≠ticas
echo.
set /p "NOVO_ALERT=Digite o novo n√≠vel de alerta (em %%): "

if "!NOVO_ALERT!" geq "50" if "!NOVO_ALERT!" leq "95" (
    set "MONITOR_ALERT_LEVEL=!NOVO_ALERT!"
    echo.
    echo ‚úÖ N√≠vel de alerta alterado para !MONITOR_ALERT_LEVEL!%%!
) else (
    echo.
    echo ‚ùå N√≠vel inv√°lido! Use valores entre 50 e 95%%.
)
echo.
pause
goto :MonitorSettings

:TestMonitor
echo.
echo üß™ TESTE R√ÅPIDO DO MONITOR
echo ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
echo.
echo üîÑ Executando teste de 10 segundos...
echo üí° O monitor ser√° exibido por alguns ciclos
echo.
timeout /t 3 > NUL

for /l %%i in (1,1,5) do (
    cls
    echo üß™ TESTE DO MONITOR - Ciclo %%i/5
    echo ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    call :GetRealTimeMemoryData
    echo.
    echo üíæ Mem√≥ria: !USED_MB!MB/!TOTAL_MB!MB (!PERCENT_USED!%%^)
    call :DrawMemoryBar !PERCENT_USED!
    echo.
    echo ‚è∞ Aguardando !MONITOR_REFRESH! segundos...
    timeout /t !MONITOR_REFRESH! > NUL
)

echo.
echo ‚úÖ Teste conclu√≠do! O monitor est√° funcionando corretamente.
echo.
pause
goto :MonitorSettings

:RestoreDefaults
echo.
echo üîÑ RESTAURAR CONFIGURA√á√ïES PADR√ÉO
echo ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
echo.
set "INTERVALO=30"
set "MONITOR_REFRESH=2"
set "MONITOR_ALERT_LEVEL=85"
echo ‚úÖ Todas as configura√ß√µes foram restauradas para os valores padr√£o!
echo    ‚Ä¢ Intervalo de limpeza: 30 segundos
echo    ‚Ä¢ Atualiza√ß√£o do monitor: 2 segundos  
echo    ‚Ä¢ N√≠vel de alerta: 85%%
echo.
pause
goto :Settings

:Help
cls
call :DrawHeader
echo ‚ùì AJUDA E INFORMA√á√ïES
echo ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
echo.
echo üßπ LIMPEZA R√ÅPIDA:
echo    ‚Ä¢ Libera mem√≥ria RAM ocupada desnecessariamente
echo    ‚Ä¢ For√ßa coleta de lixo do .NET Framework
echo    ‚Ä¢ Otimiza cache do sistema
echo    ‚Ä¢ Tempo estimado: 10-30 segundos
echo.
echo ‚ö° LIMPEZA AUTOM√ÅTICA:
echo    ‚Ä¢ Executa limpeza r√°pida automaticamente
echo    ‚Ä¢ Configur√°vel de 10 a 3600 segundos
echo    ‚Ä¢ Ideal para uso cont√≠nuo
echo    ‚Ä¢ Pressione Ctrl+C para parar
echo.
echo üîß LIMPEZA AVAN√áADA:
echo    ‚Ä¢ Inclui limpeza de mem√≥ria + arquivos tempor√°rios
echo    ‚Ä¢ Remove cache de sistema e prefetch
echo    ‚Ä¢ Limpa lixeira e otimiza mem√≥ria virtual
echo    ‚Ä¢ Tempo estimado: 1-5 minutos
echo.
echo ÔøΩ MONITOR EM TEMPO REAL:
echo    ‚Ä¢ Monitor visual de mem√≥ria em tempo real
echo    ‚Ä¢ Barra de progresso ASCII colorida
echo    ‚Ä¢ Alertas configur√°veis por n√≠vel de uso
echo    ‚Ä¢ Lista dos processos com maior consumo
echo    ‚Ä¢ Atualiza√ß√£o autom√°tica configur√°vel
echo.
echo ‚ö†Ô∏è  REQUISITOS:
echo    ‚Ä¢ Windows 10/11
echo    ‚Ä¢ Executar como administrador
echo    ‚Ä¢ PowerShell habilitado
echo.
echo üìÑ LICEN√áA E TERMOS:
echo    ‚Ä¢ Licen√ßa: Creative Commons BY-NC 4.0
echo    ‚Ä¢ Uso n√£o-comercial permitido
echo    ‚Ä¢ Atribui√ß√£o obrigat√≥ria ao redistribuir
echo    ‚Ä¢ Consulte LICENSE e TERMOS_DE_USO.md para detalhes
echo.
echo üåê MAIS INFORMA√á√ïES:
echo    ‚Ä¢ Reposit√≥rio: https://github.com/Gabs77u/Otimizador-WIN
echo    ‚Ä¢ Licen√ßa: https://creativecommons.org/licenses/by-nc/4.0/
echo    ‚Ä¢ Desenvolvido por: %AUTHOR% - 2025
echo.
pause
goto :MainMenu

:: ============================================================================
::   üîß FUN√á√ïES AUXILIARES
:: ============================================================================

:ConfirmAction
echo ‚ùì Tem certeza que deseja %~1?
echo    [S] Sim    [N] N√£o
echo.
set /p "CONFIRM=üéØ Confirmar a√ß√£o (S/N): "

if /i "!CONFIRM!"=="s" (
    set "ERRO_LEVEL=0"
) else (
    set "ERRO_LEVEL=1"
    echo.
    echo ‚ùå Opera√ß√£o cancelada pelo usu√°rio.
    timeout /t 2 > NUL
)
goto :eof

:QuickMemoryClean
echo üîÑ Executando limpeza r√°pida...
powershell -Command "[System.GC]::Collect(); [System.GC]::WaitForPendingFinalizers(); [System.GC]::Collect()" 2>nul
%windir%\system32\rundll32.exe advapi32.dll,ProcessIdleTasks
rundll32.exe kernel32.dll,SetProcessWorkingSetSize -1,-1 2>nul
echo ‚úÖ Limpeza conclu√≠da!
goto :eof

:CleanTempFiles
set "TARGET_PATH=%~1"
set "DESCRIPTION=%~2"

if exist "!TARGET_PATH!" (
    echo üóÇÔ∏è  Limpando !DESCRIPTION!...
    del /s /f /q "!TARGET_PATH!\*.*" 2>nul
    for /d %%d in ("!TARGET_PATH!\*") do rd /s /q "%%d" 2>nul
    if not exist "!TARGET_PATH!" md "!TARGET_PATH!" 2>nul
    echo ‚úÖ !DESCRIPTION! limpo!
) else (
    echo ‚ö†Ô∏è  !DESCRIPTION! n√£o encontrado.
)
goto :eof

:GetMemoryInfo
:: Usar PowerShell como m√©todo prim√°rio
for /f "tokens=*" %%a in ('powershell -Command "(Get-CimInstance -ClassName Win32_OperatingSystem).FreePhysicalMemory" 2^>nul') do set "FREE_KB_%~1=%%a"
for /f "tokens=*" %%a in ('powershell -Command "(Get-CimInstance -ClassName Win32_OperatingSystem).TotalVisibleMemorySize" 2^>nul') do set "TOTAL_KB_%~1=%%a"

:: Fallback para WMIC se PowerShell falhar
if not defined FREE_KB_%~1 (
    for /f "skip=1 tokens=*" %%a in ('wmic OS get FreePhysicalMemory /value 2^>nul ^| findstr "="') do (
        for /f "tokens=2 delims==" %%b in ("%%a") do set "FREE_KB_%~1=%%b"
    )
)
if not defined TOTAL_KB_%~1 (
    for /f "skip=1 tokens=*" %%a in ('wmic OS get TotalVisibleMemorySize /value 2^>nul ^| findstr "="') do (
        for /f "tokens=2 delims==" %%b in ("%%a") do set "TOTAL_KB_%~1=%%b"
    )
)

if defined FREE_KB_%~1 if defined TOTAL_KB_%~1 (
    set /a "FREE_MB_%~1=!FREE_KB_%~1!/1024"
    set /a "TOTAL_MB_%~1=!TOTAL_KB_%~1!/1024"
    set /a "USED_MB_%~1=!TOTAL_MB_%~1!-!FREE_MB_%~1!"
)
goto :eof

:ShowCleanupResults
if defined FREE_MB_before if defined FREE_MB_after (
    set /a "MEMORY_FREED=!FREE_MB_after!-!FREE_MB_before!"
    if !MEMORY_FREED! geq 0 (
        echo.
        echo üìä RESULTADO DA LIMPEZA:
        echo    üîπ Mem√≥ria antes: !USED_MB_before!MB usados / !FREE_MB_before!MB livres
        echo    üîπ Mem√≥ria depois: !USED_MB_after!MB usados / !FREE_MB_after!MB livres
        echo    üîπ Mem√≥ria liberada: +!MEMORY_FREED!MB
    )
)
goto :eof

:Exit
cls
call :DrawHeader
echo üëã Obrigado por usar o Otimizador de Mem√≥ria RAM v%VERSION%!
echo.
echo üí° DICAS PARA MANTER A PERFORMANCE:
echo    ‚Ä¢ Execute limpeza regularmente
echo    ‚Ä¢ Monitore processos com alto consumo de mem√≥ria
echo    ‚Ä¢ Mantenha apenas programas necess√°rios abertos
echo    ‚Ä¢ Considere aumentar a mem√≥ria RAM se necess√°rio
echo.
echo üåü Desenvolvido por %AUTHOR% - 2025
echo üìÑ Licen√ßa: Creative Commons BY-NC 4.0
echo üåê Mais informa√ß√µes: https://creativecommons.org/licenses/by-nc/4.0/
echo üìÇ Reposit√≥rio: https://github.com/Gabs77u/Otimizador-WIN
echo.
echo ‚öñÔ∏è  AVISO LEGAL: Este software √© fornecido "como est√°" sem garantias.
echo    Para termos completos, consulte o arquivo TERMOS_DE_USO.md
echo.
pause
exit /b 0